# Lessons Learned from ChatGPT Recurrence

原文：https://jingfengyang.github.io/gpt 

**为什么所有公开的对 GPT-3 的复现都失败了？我们应该在哪些任务上使用 GPT-3.5 或 ChatGPT？**

对于那些想要复现一个属于自己的 GPT-3 或 ChatGPT 的人而言，第一个问题是关键的。第二个问题则对那些想要使用它们的人是重要的（下文提到 GPT-3，主要是指 GPT-3.5 或 InstructGPT 的最新版本，除了一些指向 GPT-3 原文的情况）。

这篇博客包括我在仔细重新检查了一系列文章的细节之后给出的总结，以及对上面两个问题我个人的思考。这些文章包括且不限于：GPT-3, PaLM, BLOOM, OPT, FLAN-T5/PaLM, HELM 等。均为个人意见，仅供参考。如果您有更可靠的参考资料或者更实际的经验，欢迎指正。

**1**

**为什么所有公开的对GPT-3的复现都失败了？**

这里，我称之为“失败”，是指训练得出模型有接近 GPT-3 或者更大的参数量，但仍无法与 GPT-3 原始文献中报告的性能所匹配。在这一标准下，GPT-3 和 PaLM 是“成功”的，但这两个模型都不是公开的。而所有的公开模型（例如：OPT-175B 和 BLOOM-176B）都在一定程度上“失败”了。但是我们仍然可以从这些“失败”中吸取一些教训。

我们需要注意的是，假如能够多次尝试各种不同的训练设置，开源社区可能最终可以复现 GPT-3。但截至目前，训练另一个版本的 OPT-175B 的开销仍然太过高昂——对于如此大规模的模型，一次训练就将需要在约 1000 个 80G A100 GPU 上花费至少 2 个月的时间（数据来自于 OPT 的原始文献）。

尽管一些文章（例如 OPT-175B 和 GLM-130B）声称，它们在一些任务上能够匹配甚至超过原始的 GPT-3 的表现，在更多 GPT-3 已经测试过的任务上，这种声明仍然是存疑的。同时，根据大多数使用者在更多样的任务上的经验，以及 HELM 的评估来看，最近的  OpenAI GPT-3 的 API 表现也仍然比这些开源模型更好。

尽管它背后的模型可能使用了指令微调（instruction tuning, 正如 InstructGPT 那样），类似的使用了指令微调的 OPT 版本（OPT-IML）和 BLOOM 版本（BLOOMZ）也仍然远比 InstructGPT 和 FLAN-PaLM（PaLM 的指令微调版本）要差得多。 

根据文章的细节，相比 GPT-3 和 PaLM 的成功，有多个可能的原因导致了OPT-175B 和 BLOOM-176B 的失败。我将其分为两个部分：预训练数据和训练策略。

**预训练数据**

让我们首先观察 GPT-3 是如何准备和使用预训练数据的。GPT-3 在共计 300B 的 token 上进行训练，其中 60% 来自经过筛选的 Common Crawl，其它则来自webtext2（用于训练 GPT-2 的语料库）、Books1、Books2 和维基百科。

更新版本的 GPT-3 还用了代码数据集进行训练（例如 Github Code）。每个部分的占比并不与原始数据集的大小成比例，相反，具有更高质量的数据集被更加频繁地采样。导致 OPT-175B 和 BLOOM-176B 失败的，可能是以下三个难点，它们使得开源社区难以收集到类似的数据：

\1. 第一点是一个具有良好性能的用于**筛选低质量数据**的分类器。它被用于构建 GPT-3 和 PaLM 的预训练数据集，但在 OPT 和 BLOOM 的训练中却没有被采用。一些文章已经展示，一个用更少但质量更高的数据集训练的预训练模型，可以在性能上超过另一个用更多的混合质量数据集训练的模型。当然，数据的多样性仍然是十分重要的，正如我们将在第三点中讨论的。因此，人们应当非常小心地处理在数据多样性和质量之间的权衡。

\2. 第二点是**预训练数据集的去重**。去重有助于避免预训练模型多次面对相同的数据后记住它们或者在其上过拟合，因此有助于提高模型的泛化能力。GPT-3 和 PaLM 采用了文档级别的去重，这同样被 OPT 所采用。但 OPT 预训练的去重 Pile 语料库中仍有许多重复存在，这也可能导致它较差的性能（注：在一些最近的文献中显示去重对于预训练语言模型的重要性可能没有想象中大）。

\3. 第三点是**预训练数据集的多样性**，包括领域多样性、格式多样性（例如：文本、代码和表格）和语言多样性。OPT-175B 所使用的 Pile 语料库声称有着更好的多样性，但 BLOOM 采用的 ROOTS 语料库则有太多的已经存在的学术数据集，缺乏 Common Crawl 数据所包含的多样性。这可能导致 BLOOM 性能更差。作为对比，GPT3 来自 Common Crawl 语料的占比则要高得多，而它们来自广泛领域，是多样的，这也可能是 GPT-3 能够作为首个通用聊天机器人 ChatGPT 的基础模型的原因之一。

请注意：虽然一般来说，多样性的数据对于训练一个通用的 LLM（Large Language Model，大规模语言模型）是重要的，但特定的预训练数据分布，则会对 LLM 在特定的下游任务上的性能产生巨大的影响。例如，BLOOM 和 PaLM 在多语言数据上有更高的占比，这导致它们在一些多语言任务和机器翻译任务上的性能更高。

OPT 使用了很多对话数据（例如 reddit），这可能是它在对话中表现好的原因之一。PaLM 有很大的占比在社交媒体对话中，这可能是它在多种问答任务和数据集上有着卓越表现的原因。同样的，PaLM 和更新版本的 GPT-3 有很大比例的代码数据集，这增强了它们在代码任务上的能力，以及可能增强了它们 CoT (Chain-of-Thought，思维链) 的能力。

一个有趣的现象是，BLOOM 在代码和 CoT 上的表现仍然是较差的，尽管它在预训练过程中使用了代码数据。这可能暗示着单独代码数据本身并不能保证模型的代码和 CoT 能力。 

总之，一些文章表明了上面三点的重要性，即：**通过数据去重避免记忆和过拟合，通过数据筛选以得到高质量数据，保证数据多样性以确保 LLM 的泛化性。**但不幸的是，对于 PaLM 和 GPT-3 预处理这些数据的细节，或者这些预训练数据本身，仍然没有公布，这使得公共社区很难去复现它们。

**训练策略**

此处训练策略包括训练框架、训练持续时间、模型架构/训练设置、训练过程中的修改。在训练非常大的模型时，它们被用于获得更好的稳定性和收敛性。

一般来说，由于未知的原因，预训练过程中广泛观察到损失尖峰（loss spike）和无法收敛的情况。因此，众多的对训练设置和模型架构的修改被提出，用以避免这些问题。但是其中一些修改在 OPT 和 BLOOM 之中还不是最优解，这可能导致它们的性能较差。GPT-3 并没有明确提到他们是如何解决这个问题的。 

1. **训练框架。**一个参数量大于 175B 的模型往往需要 ZeRO 式的数据并行（分布式的优化器）和模型并行（包括张量并行（tensor parallel）、流水线并行（pipeline parallel），有时还包括序列并行（sequence parallel））。OPT 采用了 ZeRO 的 FSDP 实现，以及模型并行的 Megatron-LM 实现。BLOOM 采用了 ZeRO 的 Deepspeed 实现和模型并行的 Megatron-LM 实现。

PaLM 采用了 Pathways，这是一个基于 TPU 的模型并行和数据并行系统。GPT-3 的训练系统的细节仍然未知，但它们至少在一定程度上使用了模型并行（一些人称它使用了 Ray）。不同的训练系统和硬件可能导致不同的训练时的现象。显然，一些在 PaLM 的文章中呈现的、用于 TPU 训练的设置，可能并不适用于其它所有模型使用的 GPU 训练。

硬件和训练框架的一个重要的影响是，人们是否可以使用 bfloat16 去存储模型权重和中间层激活值等。这已经被证明是稳定训练的一个重要因素，因为 bfloat16 可以表示更大范围的浮点数，能够处理在损失尖峰时出现的大数值。在 TPU 上 bfloat16 是默认设置，这可能是 PaLM 能够成功的一个秘密。但是在 GPU 上，以前人们主要使用 float16，这是 V100 中混合精度训练的唯一选择。

OPT 使用了 float16，这可能是其不稳定的因素之一。BLOOM 发现了这样的问题并最终在 A100 GPU 上使用了 bfloat16，但它没有意识到这种设置的重要性，因此在第一个词向量层后引入额外的层归一化（layer normalization），用于解决他们使用 float16 的初步实验中的不稳定性。然而，这种层归一化已被证明会导致更糟糕的零样本泛化（zero-shot generalization），这可能是 BLOOM 失败的一个因素。 

2. **训练过程中的修改。**OPT 做了很多中途调整并从最近的 checkpoint 重启训练，包括改变截断梯度范数 (clip gradient norm) 和学习率，切换到简单的 SGD 优化器然后回到 Adam，重置动态损失标量 (dynamic loss scalar)，切换到更新版本的 Megatron 等等。

这种中途调整可能是 OPT 失败的原因之一。相比之下，PaLM 几乎没有做任何中途调整。它只是当损失尖峰出现时，从尖峰开始前大约 100 步的 checkpoint 重新开始训练，并跳过了大约 200-500 个 batch 的数据。仅仅依靠这种简单的重启，PaLM 就取得神奇的成功。这是由于它在预训练数据构建期间就已经完成采样，因此模型具有在 Bit 意义上的确定性，以及它对模型架构和训练设置进行了许多修改以获得更好的稳定性。PaLM 中的此类修改在下一点中展示。 

**3. 模型架构/训练设置**：为了使训练更稳定，PaLM 对模型架构和训练设置进行了多项调整，包括使用 Adafactor 的修改版本作为优化器，缩放在 softmax 之前的输出 logit，使用辅助损失来鼓励 softmax 归一化器接近 0，对词向量和其他层权重使用不同的初始化，在前馈层和层归一化中不使用偏差项，并且在预训练期间不使用 dropout。

请注意，GLM-130B 中还有更多有价值的内容关于如何稳定地训练非常大的模型，例如：使用基于 DeepNorm 的后置层归一化而不是前置层归一化，以及词向量层梯度收缩。以上大多数模型修改没有被 OPT 和 BLOOM 采用，这可能会导致它们的不稳定和失败。 

**4. 训练过程**：如下表所示，原始的 GPT-3 预训练过程见过的 token 数与 OPT 和 BLOOM 接近，而 PaLM 则远远超过了它们。同样，PaLM 和 GPT-3 预训练语料库都大于 BLOOM 和 OPT。因此，在更多的 token 上、用更大规模的高质量语料库进行预训练可能是 GPT-3 和 PaLM 成功的一个重要因素。

![图片](https://mmbiz.qpic.cn/mmbiz_png/lBhAE42wKWr7mNicwWOWJIIktk3QMXW6DmhPZbaTvr8hSs8yyDsUFFuRHn9LvDTibmqzSUiaGXWvsFOib5gA2pOung/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

除了上面列出的四点，还有一些其它因素，它们可能对于更稳定的训练并不重要，但仍然可能影响最终的性能。

第一点，**PaLM 和 GPT-3 都使用了在训练过程中从小到大逐渐增加的 batch size**，这已经被证明对于训练一个更好的 LLM 是有效的，然而 OPT 和 BLOOM 都使用了恒定的 batch size。

第二点，OPT 使用了 ReLU 激活函数，而 PaLM 使用 SwiGLU 激活函数，**GPT-3 和 BLOOM 使用 GeLU，它通常使得训练的 LLM 的性能更好。**

第三点，为了更好的建模更长的序列，PaLM 使用 RoPE 词向量，BLOOM 使用 ALiBi 词向量，**而原始的 GPT-3 和 OPT 使用学习得到的词向量，这可能影响在长序列上的性能。**

**2**

**我们应该在哪些任务上使用GPT-3.5或ChatGPT？**

我尝试解释我们应该在哪些任务和应用上使用 GPT-3，而哪些则不该使用。为了展示 GPT-3 是否适合某个特定任务，我主要比较了带有提示（prompting）的 GPT-3 和经过微调的更小的模型，这些小模型有时还加入了其他特殊的设计。鉴于最近出现的更小的而且可以微调的 FLAN-T5 模型的良好性能，这一问题更加重要。

在理想情形下，如果微调 GPT-3 的负担是能够承担的，它可能带来更进一步的提升。然而，在一些任务上通过微调 PaLM-540B 带来的提升是如此有限，让人们怀疑在一些任务中微调 GPT-3 是否是值得的。从科学的角度来看，更公平的比较应在微调 GPT-3 和提示 GPT-3 之间进行。然而，要使用 GPT-3，人们可能更关心将提示 GPT-3 和微调一个更小的模型去进行对比。

注意到，我主要关心的是将完成任务的精确度作为度量，但仍然存在很多其它重要的维度，例如：有害性（toxicity）、公平性等，它们也应该在决定是否使用 GPT-3 时被纳入考虑，正如 HELM 的文章中所呈现的。下图展示了一个粗略的决策流程，希望它能够作为一个有用的实践指南，无论对于已有任务还是一个全新的任务。

![图片](https://mmbiz.qpic.cn/mmbiz_png/lBhAE42wKWr7mNicwWOWJIIktk3QMXW6DsZHKa3Y4GPhuXC25VhcaRia49t6GMqnL7PegBZoxdCfZvTKXWbLts5w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

注 1：由于在对话场景下的良好对齐，ChatGPT 作为一个聊天机器人表现优异。但我们通常使用 GPT-3、InstructGPT (GPT-3.5)、以及 Codex 这些 ChatGPT 背后的模型作为在更多任务和使用场景下的通用模型。 

注 2：这一节中的结论是基于一些对模型当前版本的发现得到的，这可能不适用于未来的更强的模型。因为，使用更多与目标数据集接近的预训练数据、学术数据集指令调整（例如提示一个 FLAN-PaLM 可能会带来更强的性能，它仍未公开）或者通过 RLHF 以使得模型对目标任务的更好对齐，这些都可能使得模型在目标任务中表现更好，即使有时这会牺牲在其他场景下的能力（例如，InstructGPT的“对齐税/Alignment tax”）。

在这种情况下，很难判断 GPT 是进行泛化和跨任务泛化，还是仅仅在预训练时就已经记住了一些测试样例，或者说见过那些在预训练时所谓“没有见过”的任务。然而，记忆在实践中是否真的是一个严重的问题，这仍然值得怀疑。因为用户与研究人员不同，如果他们发现 GPT 已经可以在他们的测试数据上表现良好，他们可能不会关心 GPT 在预训练期间是否看到了相同或相似的数据。

不论如何，为了最大化这一节在当前的实用价值，我尽最大努力，试图比较微调公共的更小型的模型（T5、FALN-T5、一些特殊设计的微调 SOTA 模型等）和最近的 GPT-3 (GPT-3.5、InstructGPT)、PaLM（或 FLAN-PaLM）的最佳性能，如果这些模型的测评数据够获得的话。

一般来说，有以下这些情况更适合使用提示 GPT-3。令人惊讶的是，如果我们回看 GPT-3 论文的介绍部分，在那里很多初始设计时的目标涵盖了这些任务。这意味着那些当初宏伟的目标已经被部分实现了。 

**1. 创造性和复杂的任务**：包括代码（代码补全、自然语言指令生成代码、代码翻译、bug 修复）、文本摘要、翻译、创造性写作（例如写故事、文章、邮件、报告，以及写作的改进等）。正如原始的 GPT-3 文献中所示，GPT-3 被设计用于那些困难和“不可能标注”的任务。在一定程度上，对于这些任务，先前那种经过微调的模型不可能应用于真实世界的应用；而 GPT-3 使它们成为可能。举个例子，最近的文章显示，过去的人类标注的文本摘要已经被 LLM 生成的摘要所超越。

在某些需要从低、中资源语言翻译到英语的机器翻译任务中，通过提示 PaLM-540B，它甚至能够超越微调模型。

在 BLOOM-176B 中也观察到了类似的趋势。这是因为英语数据通常在预训练语料库中占了很大比例，因此 LLM 擅长生成英语语句。注意到，为了在代码任务中获得良好性能，尽管 Codex 和 PaLM 已经在整体上具有比之前模型更好的性能，我们仍需允许 LLM 多次（k 次）采样，以通过测试样例（使用 pass@k 作为度量）。 

**2. 只有少数标注或者没有标注数据的任务**。正如原始的 GPT-3 文献所说，GPT-3 是为了那些“昂贵标注”的任务设计的。在这种情况下，用极少量标注数据微调一个更小的模型通常不可能达到 GPT-3 在零样本（zero-shot）、单样本（one-shot）或少样本（few-shot）的情况下的表现。 

**3. 分布外（Out-of-distribution, OOD）泛化**。给定一些训练数据，传统的微调可能会过拟合训练集并且有较差的分布外泛化能力；而少样本的上下文学习（in-context learning）能够有更好的分布外泛化性。例如，带有提示的 PaLM 能够在对抗自然语言推断任务（Adversarial Natural Language Inference，ANLI）上超越经过微调的 SOTA 模型，而它在正常的语言推断任务上可能仍然劣于微调的 SOTA。

另一个例子是提示 LLM 比微调模型显示出更好的组合泛化能力。更好的分布外泛化性可能是因为在上下文学习期间不需要更新参数，避免了过拟合；或者因为那些过去的分布外样例对于 LLM 而言是分布内的。这种使用场景被阐释为 GPT-3 的初始设计目标之一：“微调模型在特定任务的数据集上的性能可以达到所谓的人类水平，实际上可能夸大了在真实世界中该任务上的性能，这是因为模型只是学到了训练集中存在的虚假的相关性，以及模型过度拟合了这个训练集狭窄的分布。” 

\4. 需要**处理多种任务的能力**，而非关注特定任务上的卓越表现。聊天机器人就是这样一种场景，其中，用户期待它能够正确地响应各种各样的任务。这可能就是为什么 ChatGPT 是 GPT-3 最成功的使用场景之一。 

\5. 那些检索不可行的**知识密集型任务**。存储在 LLM 中的知识可以显著地提高在知识密集型任务的性能，例如闭卷问答和 MMLU（一个基准数据集，包括来自于 STEM、人文、社科等 57 个学科的选择题，它用于测试 LLM 的世界知识和问题解答的能力）。然而，如果预先检索的步骤可以被加入来做检索增强的生成，一个微调的更小的模型（例如 Atlas 模型）甚至可以有更好的性能（在闭卷的 NaturalQuestions 和 TrivialQA 数据集上，Atlas 比 PaLM 和最新的 InstructGPT 都要更好）。

检索或者传统的搜索同样是将 GPT-3 或 ChatGPT 整合到搜索引擎中的一个必要的步骤，这可以提升生成的准确性，并且提供更多的参考链接以增强说服力。但我们应该承认，在某些情况下，检索是不允许或者不容易的，比如参加 USMLE (美国医学执照考试)，谷歌已经证明基于 FLAN-PaLM 的模型可以在其中做得很好。

同样的，在 MMLU 基准集中，PaLM-540B 有着比其他微调模型更好的性能，甚至后者结合了检索，尽管最新版本的 InstructGPT 还差于这些带有检索的微调 SOTA。也请注意，指令调整一个较小的模型也可以实现与更大规模的 LLM 模型接近的效果，这已经在 FLAN-T5 中展现。 

\6. 一些**困难的任务**，其中需要**LLM 的涌现能力**，比如带有 CoT 的推理和 BIG-Bench 中的复杂任务（包括逻辑推理、翻译、问答、数学任务等）。举个例子，PaLM 已经展示，在 7 个包括数学和常识推理的多步推理任务上，8-样例的 CoT 比微调 SOTA 在其中 4 个任务上更好，在其它 3 个任务上则基本持平。

这样的成功表现要同时归因于更大规模的模型和 CoT。PaLM 还显示了在 BIG-Bench 任务上从 8B 到 62B 再到 540B 模型的不连续的表现提升，这超出了规模定律（scaling law），被称为 LLMs 的涌现能力。另外，带有 5 个 Prompt 的 PaLM-540B 在 Big-Bench 的 58 项常见任务中的 44 项上优于之前的（少样本）SOTA。PaLM-540B 在 Big-Bench 的总体表现也优于人类的平均表现。 

\7. 一些需要**模仿人类**的场景，或者是其目标是**制作性能达到人类水平的通用人工智能**。同样的，ChatGPT 是其中的一个案例，ChatGPT 使自己更像是一个人，从而取得了现象级的成功。这也被阐释为 GPT-3 的初始设计目标之一：“人类不需要大规模监督数据集来学习大多数语言任务。最多只需要几个例子，人类就可以将各种任务和技巧无缝地混合在一起或者在它们之间切换。因此传统的微调模型导致了与人类的不公平比较，尽管他们声称在许多基准数据集中有着人类水平的性能。” 

\8. 在**一些传统的接近于语言建模的 NLP 任务上**，少样本 PaLM-540B 能够大致匹配或者甚至超过微调的 SOTA，例如：一段话最后一句和最后一个单词的完型填空，以及回指（anaphora）解析。需要指出，在这种情况下，零样本的 LLM 已经足够了，单样本或少样本的示例则通常帮助不大。

另一些任务则并不需要提示（prompt）一个 GPT-3 这样规模的模型： 

\1. 调用 OpenAI GPT-3 的 API 超出了预算（例如对于没有太多钱的创业公司）。 

\2. 调用 OpenAI GPT-3 的 API 存在安全问题（例如数据泄露给 OpenAI，或者可能生成的有害内容）。

\3. 没有足够的工程或者硬件资源去部署一个相似大小的模型及消除推断的延迟问题。例如，在没有最先进的 80G 的 A100 或者工程资源来优化推断速度的情况下，简单地使用 Alpa 在 16 个 40G 的 A100 上部署 OPT-175B 需要 10 秒才能完成单个样例的推断，这对于大多数现实世界的在线应用程序来说是无法接受的延迟。 

\4. 如果想用 GPT-3 替代一个性能良好的、高准确度的微调模型，或者想要在一些特定的单一任务和使用场景下去部署一个 NLU（Natural Language Understanding，自然语言理解）或 NLG（Natural Language Generating，自然语言生成）模型，请三思这是否值得。

- 对于一些传统的 NLU 任务，比如分类任务，我建议首先尝试微调 FLAN-T5-11B 模型，而不是提示 GPT-3。例如，在 SuperGLUE，一个困难的 NLU 基准数据集（包括阅读理解、文本蕴含、词义消歧、共指消解和因果推理等任务）上，所有的 PaLM-540B 的少样本提示性能都劣于微调的 T5-11B，并在其中大多数任务上有着显著的差距。如果使用原始 GPT3，其提示结果与微调 SOTA 的结果之间的差距更大。有趣的是，即使是经过微调的 PaLM 也仅比经过微调的 T5-11B 有着有限的改进，而经过微调的 PaLM 甚至比经过微调的编-解码器模型 32B MoE 模型还要差。这表明使用更合适的架构（例如编-解码器模型）微调较小的模型仍然是比使用非常大的仅解码器模型更好的解决方案，无论是微调还是提示来使用这些大模型。根据最近的一篇论文，即使对于最传统的 NLU 分类任务——情感分析，ChatGPT 仍然比经过微调的较小模型差。

- 一些不以现实世界数据为基础的困难任务。例如，BigBench 中仍然有许多对 LLM 来说困难的任务。具体地说，在 35% 的 BigBench 任务上，人类的平均表现仍然高于 PaLM-540B，并且在某些任务中，扩大模型规模甚至无济于事，例如导航和数学归纳。在数学归纳中，当提示中的假设不正确时（例如“2 是奇数”），PaLM 会犯很多错误。在逆规模定律竞赛 (Inverse Scaling Law Challenge) 中，也观察到了类似的趋势，例如重新定义数学符号（例如提示可能“将 π 重新定义为 462”）后再使用这个符号。在这种情况下，LLM 中的现实世界先验知识太强而无法被提示覆盖，而微调较小的模型可能可以更好地学习这些反事实知识。

- 在很多多语言任务和机器翻译任务中，使用少样本的提示 GPT 仍然要比微调的更小的模型更差。这很可能是由于除英语之外的其它语言在预训练语料库中占比很少。

- 当从英语翻译为其他语言，以及翻译高资源语言到英语时，PaLM 和 ChatGPT 仍然比在机器翻译任务上微调的更小的模型要差。
- 对于多语言问答任务来说，在少样本的 PaLM-540B 和微调的更小模型之间还存在较大差距。
- 对于多语言文本生成（包括文本摘要和数据到文本生成），在少样本的 PaLM-540B 和微调的更小模型之间还存在较大差距。在大部分任务上即使微调的 PaLM-540B 也仅仅比微调的 T5-11B 有有限的提升，并仍然劣于微调的 SOTA。

- 对于常识推理任务，在最好的少样本提示 LLM 和微调的 SOTA 之间仍然存在着较大的差距，例如：OpenbookQA，ARC（包括 Easy 和 Challenge 版本）以及 CommonsenseQA（甚至使用了 CoT 提示）。

- 对于机器阅读理解任务，在最好的少样本提示 LLM 和微调的 SOTA 之间仍然存在着较大的差距。在大多数数据集上，这个差距可能非常巨大。这可能是因为所有回答问题所需的知识都已经包含在给出的文本中，并不需要 LLM 中的额外知识。

总结一下，上面的这些任务可以被归为以下类别之一： 

1. **一些 NLU 任务，既不需要额外的知识也不需要 LLM 的生成能力**。这意味着测试数据大多数都和手头的训练数据在同一个分布之中。在这些任务上，过去微调的较小模型已经表现很好了。 

2. **一些不需要额外的来自 LLM 中知识的任务**，因为每一个例子已经在上下文或者提示中包含了足够的知识，例如机器阅读理解。

 

3. **一些需要额外知识，但不太可能从 LLM 中获得这样的知识，或者 LLM 不太可能见过类似分布的任务**，例如一些低资源语言中的任务，LLM 在这些语言中只有有限的预训练样本。

4. **一些任务，需要与 LLM 中包含的知识所不一致的知识****，或者并非基于现实世界的语言数据的知识**。因为 LLM 是在现实世界的语言数据上训练的，它难以在新的任务中利用反事实知识覆盖原有知识。除了在逆规模定律挑战中的“重新定义数学符号”问题之外，还有另一个任务，即复述有细微改动的名言，其中 LLM 被要求复述一个在 prompt 中出现的被修改的名言。在这种情况下，LLM 倾向于重复出名言的原始版本，而非修改过后的版本。 

5. **一些任务需要来自 LM 的知识，但也严重依赖于操纵这些知识**，而 LLM 的“预测下一个 token”的目标无法轻易实现这种操纵。一个例子是一些常识推理任务。CoT 和 least-to-most 提示可以帮助 LLM 推理的原因可能是他们可以更好地调出那些连续的预训练文本，这些连续文本恰好模仿了规划和分解/组合知识的过程。

因此，CoT 和 least-to-most 提示在一些数学推理、代码和其他简单的自然语言推理任务中表现良好，但在许多常识推理（例如在逆规模定律竞赛中展示的演绎推理任务）和自定义符号推理任务中仍然表现不佳。这些任务通常不被自然语言数据中的大多数真实世界的连续序列所包含，而需要操纵分散在各处的知识来完成。 

6. **一些容易受到上下文学习样例或者真实世界数据中存在的虚假相关性影响的任务**。一个例子是来自于逆规模定律竞赛中的涉及否定词的问答。如果一个 LLM 被提问：“如果一只猫的体温低于平均水平，它就不在……”，它倾向于回答“危险之中”而非“安全范围“。这是因为 LLM 受到常见的“低于平均体温”和“危险”之间的关系所支配，而在否定的情况下，这是一种虚假的相关性。 

7. **一些目标与处理语言数据显著不同的任务**，例如：回归问题，其中微调模型很难被 LLM 取代。至于多模态任务，它们不能被 LLM 解决，但是可能能从大规模的预训练多模态模型中受益。

 

8. **一些任务不需要LLM的涌现能力**。为了准确地对更多此类任务进行鉴别，我们需要更好地了解 LLM 训练期间，涌现能力是从何产生的。 

注意到，在现实世界的使用场景中，即使由于无法满足延迟要求因而无法在线地使用 LLM，仍然可以使用 LLM 离线生成或标注数据。此类自动标注的标签可以在线查找并提供给用户，或用于微调较小的模型。使用此类数据微调较小的模型可以减少训练模型所需的人工注释数据，并将 LLM 的一些新兴能力（例如 CoT）注入较小的模型。 

总之**，当有足够的标记数据时，考虑到开源 FLAN-T5 在许多任务中的惊人性能，我推荐那些调用 OpenAI API 的资源有限的个体，应该首先尝试在目标任务上微调 FLAN-T5-11B。**此外，根据最近在 MMLU 数据集上，FLAN-PaLM-540B 与最新版本的 InstructGPT 的性能（根据 HELM）相比好得惊人的性能，谷歌可能拥有比 OpenAI 更强大的基础模型，如果 OpenAI 已经通过 API 发布了他们获得的最强的 LLM。

谷歌唯一剩下的步骤是通过人类反馈使这个 LLM与对话场景对齐（alignment）。如果他们很快发布类似 ChatGPT 的或者更好的聊天机器人，我不会感到惊讶——尽管他们最近“失败”地展示了一版可能基于 LaMDA 的 Bard。

**参考文献：**

[1] HELM: Holistic Evaluation of Language Models and its board: https://crfm.stanford.edu/helm/v0.2.0/?group=core_scenarios

[2] GPT3: Language Models are Few-Shot Learners

[3] PaLM: Scaling Language Modeling with Pathways

[4] OPT: Open Pre-trained Transformer Language Models

[5] BLOOM: A 176B-Parameter Open-Access Multilingual Language Model

[6] FLAN-T5/PaLM: Scaling Instruction-Finetuned Language Models

[7] The Flan Collection: Designing Data and Methods for Effective Instruction Tuning

[8] InstructGPT: Training language models to follow instructions with human feedback

[9] Yao Fu’s blog on “Tracing Emergent Abilities of Language Models to their Sources”

[10] Inverse Scaling Prize: https://github.com/inverse-scaling/prize

[11] Is ChatGPT a General-Purpose Natural Language Processing Task Solver?



